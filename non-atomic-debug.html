<!DOCTYPE html>
<html>
<head>
    <title>Non-Atomic Debug - With Error Checking</title>
    <style>
        body { font-family: monospace; padding: 20px; }
        #output { white-space: pre-wrap; background: #f0f0f0; padding: 15px; }
        button { padding: 12px; font-size: 16px; margin: 5px; }
    </style>
</head>
<body>
    <h1>Non-Atomic Debug (Error Checking)</h1>
    <button onclick="runTest()">Run Test</button>
    <div id="output">Click to run...</div>

<script>
const shaderCode = `
@group(0) @binding(0) var<storage, read_write> results: array<u32>;

var<workgroup> test_var: u32;

@compute @workgroup_size(2, 1, 1)
fn main(@builtin(local_invocation_index) idx: u32) {
    if (idx == 0u) {
        test_var = 0u;
    }
    workgroupBarrier();
    
    if (idx == 0u) {
        test_var = 42u;
        results[0] = 888u;
    }
    
    workgroupBarrier();
    
    if (idx == 1u) {
        results[1] = test_var;
    }
    
    workgroupBarrier();
}
`;

let device = null;
const output = document.getElementById('output');

async function runTest() {
    output.textContent = 'Initializing...';
    
    try {
        if (!device) {
            if (!navigator.gpu) {
                output.textContent = '❌ WebGPU not supported';
                return;
            }
            
            const adapter = await navigator.gpu.requestAdapter();
            if (!adapter) {
                output.textContent = '❌ No GPU adapter';
                return;
            }
            
            device = await adapter.requestDevice();
            output.textContent = '✓ Device acquired\n';
        }
        
        output.textContent += 'Compiling shader...\n';
        const module = device.createShaderModule({ 
            code: shaderCode,
            compilationHints: [{
                entryPoint: 'main'
            }]
        });
        
        // Check for compilation errors
        const compilationInfo = await module.getCompilationInfo();
        if (compilationInfo.messages.length > 0) {
            output.textContent += '\n⚠️ Shader compilation messages:\n';
            for (const msg of compilationInfo.messages) {
                output.textContent += `${msg.type}: ${msg.message}\n`;
            }
        }
        
        output.textContent += 'Creating pipeline...\n';
        const pipeline = device.createComputePipeline({
            layout: 'auto',
            compute: { module, entryPoint: 'main' }
        });
        
        output.textContent += 'Creating buffers...\n';
        const resultBuffer = device.createBuffer({
            size: 8,
            usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC
        });
        
        const readBuffer = device.createBuffer({
            size: 8,
            usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ
        });
        
        output.textContent += 'Creating bind group...\n';
        const bindGroup = device.createBindGroup({
            layout: pipeline.getBindGroupLayout(0),
            entries: [{ binding: 0, resource: { buffer: resultBuffer } }]
        });
        
        output.textContent += 'Encoding commands...\n';
        const encoder = device.createCommandEncoder();
        const pass = encoder.beginComputePass();
        pass.setPipeline(pipeline);
        pass.setBindGroup(0, bindGroup);
        pass.dispatchWorkgroups(1);
        pass.end();
        encoder.copyBufferToBuffer(resultBuffer, 0, readBuffer, 0, 8);
        
        output.textContent += 'Submitting to GPU...\n';
        device.queue.submit([encoder.finish()]);
        
        output.textContent += 'Waiting for results...\n';
        await readBuffer.mapAsync(GPUMapMode.READ);
        const results = new Uint32Array(readBuffer.getMappedRange());
        
        output.textContent += '\n✓ EXECUTION COMPLETE\n\n';
        output.textContent += `results[0]: ${results[0]}\n`;
        output.textContent += `results[1]: ${results[1]}\n\n`;
        
        output.textContent += `Thread 0 ${results[0] === 888 ? 'RAN' : 'DID NOT RUN'}\n`;
        output.textContent += `Thread 1 saw: ${results[1]}\n`;
        
        readBuffer.unmap();
        
    } catch (e) {
        output.textContent += `\n❌ ERROR: ${e.message}\n`;
        output.textContent += `Stack: ${e.stack}\n`;
        console.error('Full error:', e);
    }
}
</script>
</body>
</html>